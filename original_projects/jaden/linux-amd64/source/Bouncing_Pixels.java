/* autogenerated by Processing revision 1293 on 2023-08-21 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.net.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Bouncing_Pixels extends PApplet {




//Global Variables

//Variables for the server.
Client c;
String data;


//Array of pixel objects
square[] arrsquare;
 
//Number variable.
int num = 40;


public void setup(){
  /* size commented out by preprocessor */;
  background(40);
  /* smooth commented out by preprocessor */;
  rectMode(CENTER);
  
//Set the size of the array.
  arrsquare = new square[num];
  
//Use a loop to create instances of square object
  for(int i = 0; i < arrsquare.length; i++){
    arrsquare[i] = new square();
  }
  
  //Connect to the server for the mouse position.
  c = new Client(this, "localhost", 9999);
}

float myMouseY = -100;

float myMouseX = -100;

public void draw(){
  
  if (c.available() > 0) {
    // read the data from the client
    data = c.readString();
    //Split the msg.
    String[] xy = split(data, ',');
    
    float x = PApplet.parseFloat(xy[0]);
    float y  = PApplet.parseFloat(xy[1]);
    
    
    //Set the mouse position to the data from the server.
    myMouseX = PApplet.parseInt(map(PApplet.parseInt(x),0,640,0,width));
    myMouseY = PApplet.parseInt(map(PApplet.parseInt(y),0,480,0,height));
  }
    
//Array of pixels -- Update, Collide, Display
  for(int i = 0; i < arrsquare.length; i++){
    
    arrsquare[i].moveAwayFromCursor(myMouseX, myMouseY);
    
//Update pixel location
    arrsquare[i].update();
    
//Check if they have collided with the walls
    arrsquare[i].collide();
    
    
     float distance = dist(arrsquare[i].location.x, arrsquare[i].location.y, myMouseX, myMouseY); 
      if(distance < arrsquare[i].size){
        arrsquare[i].rgb = color(255,255,255,30);
      }
  
    
//Check if the current pixel is touching all the other pixels
    for(int n = 0; n < arrsquare.length; n++){
//Calculate the distance between pixels
        distance = dist(arrsquare[i].location.x, arrsquare[i].location.y, arrsquare[n].location.x,arrsquare[n].location.y); 
        
//If distance from one pixel to every other pixel is < the the pixel's radius, they are touching
        if(i != n && (distance < arrsquare[i].size/2 + arrsquare[n].size/2)){
          
//Change the alpha of the pixels
           arrsquare[i].highlight();
           arrsquare[n].highlight();
        }
     }
     arrsquare[i].display();
   }
   checktime();
   fill(255,5);
   noStroke();
   println(myMouseX);
   ellipse(myMouseX,myMouseY,50,50);
}


public void checktime(){
   
  if(millis() > 30000){
   
    exit();
  }
  
}

//Class for our pixel object
class square {
  
//Data
//The diameter of the pixel
  int size;
  
//The color value
  int rgb;
  
//Temp value so alpha can be changed
  int tempRgb;
  
//PVector for the object location -- Defines x,y coordinates
  PVector location;
  
//PVector for the object velocity -- Defines the vector(angle & magnitude) of change in location
  PVector velocity;
  
//PVector for the object acceleration -- Defines the vector(angle & magnitude) of change in velocity
  PVector acceleration;
  
//Variable for the velocity top speed
  float topSpeed;

//Constructor: Where all the Data is intialized-- Run once
  square(){
    
//Random pixel size
    size = PApplet.parseInt(random(20,90));
    
//Random size for the location vector
    location = new PVector(random(size,width-size),random(size,height-size));
//If location is past the left and right sides of the screen, reverse the motion
    if((location.x > (width-size)) || (location.x < size)){
      velocity.x = velocity.x * -1;
    }
   
//If  location is past the top and bottom sides of the screen, reverse the motion
    if((location.y > (height-size)) || (location.y < size)){
      velocity.y = velocity.y * -1;
    }
//Velocity is set to an intial value of 0,0-- no velocity
    velocity = new PVector(0,0);
    
//Acceleration updates velocity
//first random makes them go to the side, second random makes them go down
    acceleration = new PVector(random(0,0),random(0,0.05f));
    
//Limit top speed of pixel
    topSpeed = 10;
    
//RGB is a random color
//I chose to do any color between red and pink
    rgb = color(PApplet.parseInt(random(214,245)),PApplet.parseInt(random(57,60)),PApplet.parseInt(random(0,255)));
    
//Save the value of rgb in a temp variable so we can reset it after alpha change
    tempRgb = rgb;
  }
  
//Methods
  
//Update the location of the object
  public void update(){
    
//Add acceleration to velocity
    velocity.add(acceleration);
    
//Limit the top speed to 1
    velocity.limit(topSpeed);
    
//Add velocity to acceleration
    location.add(velocity);
  }
  
public void moveAwayFromCursor(float cursorX, float cursorY){
  
  PVector mouse = new PVector(cursorX, cursorY);
//calculate the vector pointing away from the cursor
  PVector direction = PVector.sub(location, mouse);
//setting the magnitude (amount) of the acceleration based on distance from cursor
  float distance = direction.mag();
//if less than 100, push
  if(distance < 100){
    float magnitude = map(distance, 0, 100, 0.25f, 0);
    direction.normalize();
    direction.mult(magnitude);
    acceleration = direction;
  } else{
    //acceleration.mult(0);
  }
}
//Check if pixels touch the walls
  public void collide(){
    
//If the location is past the left and right sides of the screen, reverse the motion
    if((location.x > (width - size/2)) || (location.x < size/2)){
      velocity.x = velocity.x * -1; 
    }
    
//If the location is past the top and bottom sides of the screen, reverse the motion
    if((location.y > (height - size)) || (location.y < size/2)){
      velocity.y = velocity.y * -1; 
    }
    
  }
  
//Change the alpha of the color
  public void highlight(){
    rgb = color(rgb,150);
  }

//Display the pixel
  public void display(){
    strokeWeight(4);
    stroke(214,11,130,50);
    fill(rgb);
    rect(location.x,location.y,size,size);
    
//Reset the rgb color to it's intial value
    rgb = tempRgb;
  }
}


  public void settings() { size(800, 700, P2D);
smooth(); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "--full-screen", "--bgcolor=#666666", "--hide-stop", "Bouncing_Pixels" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
